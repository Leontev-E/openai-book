---
lang: ru
translationOf: openai-cookbook
---

# Формат отклика OpenAI harmony

[&lt;&lt;&lt;INL_0>>> модели](https://openai.com/open-models) были обучены в формате harmony response для определения структуры разговоров, генерации выводов рассуждений и организации вызовов функций. Если вы не используете &lt;&lt;&lt;INL_1>>> напрямую, а через API или провайдера, например Ollama, вам не нужно беспокоиться об этом, так как ваше решение для вывода будет обрабатывать форматирование. Если же вы создаёте собственное решение для вывода, это руководство проведёт вас по формату подсказок. Формат разработан так, чтобы имитировать OpenAI Responses API, поэтому если вы уже использовали этот API, формат должен показаться вам знакомым. &lt;&lt;&lt;INL_2>>> не следует использовать без формата harmony, так как он не будет работать корректно.

## Концепции

### Роли

Каждое сообщение, обрабатываемое моделью, имеет связанную с ним роль. Модель распознаёт пять типов ролей:

| Роль           | Назначение                                                                                                                                                                               |
| :------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| &lt;&lt;&lt;INL_3>>>    | Сообщение системы используется для указания усилий по рассуждению, метаинформации, таких как ограничение знаний и встроенные инструменты                                                |
| &lt;&lt;&lt;INL_4>>>    | Сообщение разработчика используется для предоставления информации о инструкциях модели (то, что обычно называют «системной подсказкой») и доступных инструментах функций                |
| &lt;&lt;&lt;INL_5>>>    | Обычно представляет ввод модели                                                                                                                                                          |
| &lt;&lt;&lt;INL_6>>>    | Вывод модели, который может быть вызовом инструмента или сообщением. Вывод также может быть связан с конкретным «каналом», обозначающим намерение сообщения                            |
| &lt;&lt;&lt;INL_7>>>    | Сообщения, представляющие вывод вызова инструмента. В качестве роли внутри сообщения используется имя конкретного инструмента                                                            |

Эти роли также представляют иерархию информации, которую модель применяет при конфликтах инструкций: &lt;&lt;&lt;INL_8>>> \> &lt;&lt;&lt;INL_9>>> \> &lt;&lt;&lt;INL_10>>> \> &lt;&lt;&lt;INL_11>>> \> &lt;&lt;&lt;INL_12>>>

#### Каналы

Сообщения помощника могут выводиться в трёх различных «каналах». Они используются для разделения ответов, ориентированных на пользователя, и сообщений внутреннего назначения.

| Канал         | Назначение                                                                                                                                                                                                                                                                                                            |
| :------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| &lt;&lt;&lt;INL_13>>>  | Сообщения, помеченные в «финальном» канале, предназначены для отображения конечному пользователю и представляют ответы модели.                                                                                                                                                                                         |
| &lt;&lt;&lt;INL_14>>>  | Сообщения, используемые моделью для своей цепочки рассуждений (CoT). **Важно:** Сообщения в канале анализа не соответствуют тем же стандартам безопасности, что и финальные сообщения. Избегайте показывать их конечным пользователям.                                                                                     |
| &lt;&lt;&lt;INL_15>>>  | Любой вызов функции обычно инициируется в канале &lt;&lt;&lt;INL_16>>>, в то время как встроенные инструменты обычно вызываются в канале &lt;&lt;&lt;INL_17>>>. Однако иногда встроенные инструменты также могут выводиться в &lt;&lt;&lt;INL_18>>>. Иногда этот канал может использоваться моделью для генерации [преамбулы](#preambles) к вызову нескольких функций. |

## Библиотека рендерера harmony

Рекомендуется использовать наш рендерер harmony через [PyPI](https://pypi.org/project/openai-harmony/) или [crates.io](https://crates.io/crates/openai-harmony), когда это возможно, так как он автоматически отформатирует ваши сообщения правильно и преобразует их в токены для обработки моделью.

Ниже пример использования рендерера для построения системной подсказки и короткого диалога.

&lt;&lt;&lt;CODE_0>>>

Кроме того, библиотека openai_harmony включает StreamableParser для парсинга и декодирования в процессе генерации новых токенов моделью. Это может быть полезно, например, для потокового вывода и обработки юникод-символов при декодировании.

&lt;&lt;&lt;CODE_1>>>

## Формат подсказок

Если вы выберете построение собственного рендерера, следует придерживаться следующего формата.

### Специальные токены

Модель использует набор специальных токенов для идентификации структуры вашего ввода. Если вы используете [tiktoken](https://github.com/openai/tiktoken), эти токены кодируются в кодировке &lt;&lt;&lt;INL_19>>>. Все специальные токены имеют формат &lt;&lt;&lt;INL_20>>>.

| Специальный токен      | Назначение                                                                                                                         | ID токена |
| :--------------------- | :--------------------------------------------------------------------------------------------------------------------------------- | :-------- |
| &lt;&#124;start&#124;>    | Обозначает начало [сообщения](#message-format). За ним следует «заголовок» сообщения, начинающийся с [роли](#roles)                  | &lt;&lt;&lt;INL_21>>> |
| &lt;&#124;end&#124;>      | Обозначает конец [сообщения](#message-format)                                                                                      | &lt;&lt;&lt;INL_22>>> |
| &lt;&#124;message&#124;>  | Обозначает переход от заголовка сообщения к его непосредственному содержимому                                                       | &lt;&lt;&lt;INL_23>>> |
| &lt;&#124;channel&#124;>  | Обозначает переход к информации о [канале](#channels) в заголовке                                                                   | &lt;&lt;&lt;INL_24>>> |
| &lt;&#124;constrain&#124;>| Обозначает переход к определению типа данных в [вызове функции](#receiving-tool-calls)                                              | &lt;&lt;&lt;INL_25>>> |
| &lt;&#124;return&#124;>   | Обозначает, что модель завершила выборку ответа. Валидный токен остановки, означающий, что нужно прекратить вывод                   | &lt;&lt;&lt;INL_26>>> |
| &lt;&#124;call&#124;>     | Обозначает, что модель желает вызвать инструмент. Валидный токен остановки, означающий, что нужно прекратить вывод                    | &lt;&lt;&lt;INL_27>>> |

### Формат сообщения

Формат отклика harmony состоит из «сообщений», и модель может генерировать несколько сообщений за раз. Общая структура сообщения следующая:

&lt;&lt;&lt;CODE_2>>>

&lt;&lt;&lt;INL_28>>> содержит набор метаинформации, включая [роль](#roles). &lt;&lt;&lt;INL_29>>> обозначает конец завершённого сообщения, но модель также может использовать другие токены остановки, такие как &lt;&lt;&lt;INL_30>>> для вызова инструментов и &lt;&lt;&lt;INL_31>>> для указания окончания генерации.

### Формат диалога

Исходя из вышеописанного формата сообщений, самый простой формат диалога состоит из сообщения &lt;&lt;&lt;INL_32>>> и начала сообщения &lt;&lt;&lt;INL_33>>>.

#### Пример ввода

&lt;&lt;&lt;CODE_3>>>

Вывод начнётся с указания &lt;&lt;&lt;INL_34>>>. Например, &lt;&lt;&lt;INL_35>>> для вывода цепочки рассуждений. Модель может вывести несколько сообщений (преимущественно цепочек рассуждений), разделяя их токеном &lt;&lt;&lt;INL_36>>>.

Когда генерация завершится, вывод прекратится либо токеном &lt;&lt;&lt;INL_37>>>, означающим завершение окончательного ответа, либо &lt;&lt;&lt;INL_38>>>, указывающим на необходимость вызова инструмента. В любом случае это означает, что нужно прекратить вывод.

#### Пример вывода

&lt;&lt;&lt;CODE_4>>>

В канале &lt;&lt;&lt;INL_39>>> будет содержаться ответ на запрос пользователя. Подробнее о цепочке рассуждений см. в разделе [reasoning](#reasoning).

**Примечание к реализации:** &lt;&lt;&lt;INL_40>>> — это токен остановки, применяемый только во время декодирования. При добавлении сгенерированного ответа ассистента в историю диалога для следующего шага замените завершающий &lt;&lt;&lt;INL_41>>> на &lt;&lt;&lt;INL_42>>>, чтобы сохраняемые сообщения были полностью сформированы как &lt;&lt;&lt;INL_43>>>. Следовательно, предыдущие сообщения в подсказках должны заканчиваться на &lt;&lt;&lt;INL_44>>>. Для целевых/тренировочных примеров уместно заканчивать на &lt;&lt;&lt;INL_45>>>; для сохранённой истории нормализуйте до &lt;&lt;&lt;INL_46>>>.

### Формат системного сообщения

Системное сообщение используется для предоставления общей информации системе. Это отличается от того, что могут назвать «системной подсказкой» в других форматах подсказок. Для этого смотрите [формат сообщения разработчика](#developer-message-format).

В системном сообщении задаётся:

1. **Идентичность** модели — она всегда должна быть &lt;&lt;&lt;INL_47>>>. Если хотите сменить идентичность модели, используйте инструкции из [сообщения разработчика](#developer-message-format).
2. Метаданные **дат** — конкретно &lt;&lt;&lt;INL_48>>> и &lt;&lt;&lt;INL_49>>>
3. Уровень **усилий по рассуждению** — как указано в уровнях &lt;&lt;&lt;INL_50>>>, &lt;&lt;&lt;INL_51>>>, &lt;&lt;&lt;INL_52>>>
4. Доступные каналы — для наилучшей производительности они должны соответствовать &lt;&lt;&lt;INL_53>>>, &lt;&lt;&lt;INL_54>>>, и &lt;&lt;&lt;INL_55>>>.
5. Встроенные инструменты — модель обучалась на базе &lt;&lt;&lt;INL_56>>> и &lt;&lt;&lt;INL_57>>> инструментов. Подробнее в разделе [встроенные инструменты](#built-in-tools).

**Если вы определяете функции,** сюда также следует включить заметку, что все вызовы функций должны идти в канал &lt;&lt;&lt;INL_58>>>.

Для наилучшей производительности придерживайтесь данного формата.

#### Пример системного сообщения

Самое базовое системное сообщение выглядит так:

&lt;&lt;&lt;CODE_5>>>

Если в сообщении разработчика есть вызовы функций, используйте:

&lt;&lt;&lt;CODE_6>>>

### Формат сообщения разработчика

Сообщение разработчика обычно считается «системной подсказкой». Оно содержит инструкции для модели и опционально список [функциональных инструментов](#function-calling), доступных для использования, или формат вывода, которому следует модель при [структурированных ответах](#structured-output).

Если вы не используете вызовы функций, сообщение разработчика будет выглядеть так:

&lt;&lt;&lt;CODE_7>>>

Где &lt;&lt;&lt;INL_59>>> — ваша «системная подсказка».

Для определения вызовов функций смотрите [специальный раздел](#function-calling).  
Для определения формата вывода в структурированных ответах смотрите [этот раздел руководства](#structured-output).

### Рассуждения

gpt-oss модели — это модели с рассуждениями. По умолчанию модель выполняет рассуждения среднего уровня. Чтобы управлять уровнем рассуждений, вы можете указать в [системном сообщении](#system-message-format) соответствующий уровень — &lt;&lt;&lt;INL_60>>>, &lt;&lt;&lt;INL_61>>>, или &lt;&lt;&lt;INL_62>>>. Рекомендуемый формат:

&lt;&lt;&lt;CODE_8>>>

Модель будет выводить необработанную цепочку рассуждения (CoT) в виде сообщений ассистента в канал &lt;&lt;&lt;INL_63>>>, а финальный ответ будет выводиться в &lt;&lt;&lt;INL_64>>>.

Например, для вопроса &lt;&lt;&lt;INL_65>>> вывод модели может выглядеть так:

&lt;&lt;&lt;CODE_9>>>

В этом случае цепочка рассуждений выглядит следующим образом:

&lt;&lt;&lt;CODE_10>>>

А фактический ответ будет:

&lt;&lt;&lt;CODE_11>>>

**Важно:**  
Модель не обучалась по тем же стандартам безопасности для цепочек рассуждений, как для финального вывода. Не показывайте цепочки рассуждений вашим пользователям, так как они могут содержать вредоносный контент. [Подробнее в карточке модели](https://openai.com/index/gpt-oss-model-card/).

#### Обработка вывода рассуждений в последующих итерациях

В целом, при последующих итерациях следует удалять предыдущее содержимое CoT, если ответы ассистента заканчивались сообщением в канал &lt;&lt;&lt;INL_66>>>. То есть, если первый ввод был таким:

&lt;&lt;&lt;CODE_12>>>

и породил такой вывод:

&lt;&lt;&lt;CODE_13>>>

Для корректной работы модели вход для следующей итерации должен быть

&lt;&lt;&lt;CODE_14>>>

Исключение — вызовы инструментов/функций. Модель может вызывать инструменты как часть своей цепочки рассуждений, и поэтому предыдущая цепочка рассуждений должна передаваться обратно в следующем вводе. Полный пример есть в разделе [вызова функций](#function-calling).

### Вызов функций

#### Определение доступных инструментов

Все функции, доступные модели, должны быть описаны в [сообщении разработчика](#developer-message-format) в специальном разделе &lt;&lt;&lt;INL_67>>>.

Для определения функций мы используем синтаксис, похожий на TypeScript, и оборачиваем функции в специальное пространство имён &lt;&lt;&lt;INL_68>>>. Важно строго придерживаться этого формата для повышения точности вызовов функций. В кодовой базе рендерера harmony можно посмотреть, как JSON-схемы аргументов преобразуются в этот формат, но есть общие рекомендации:

- Определять каждую функцию как &lt;&lt;&lt;INL_69>>>, если она не принимает аргументов
- Для функций с аргументами называть аргумент &lt;&lt;&lt;INL_70>>> и писать определение типа прямо в строке
- Добавлять комментарии с описанием над определением поля
- Всегда использовать &lt;&lt;&lt;INL_71>>> в качестве типа возвращаемого значения
- Оставлять пустую строку после каждой функции
- Оборачивать функции в пространство имён, обычно &lt;&lt;&lt;INL_72>>> — пространство имён, которое следует использовать, чтобы не конфликтовать с [встроенными инструментами](#built-in-tools), на которых обучалась модель

Вот пример полного ввода с двумя определёнными функциями:

&lt;&lt;&lt;CODE_15>>>

#### Получение вызовов инструментов

Если модель решит вызвать инструмент, она укажет &lt;&lt;&lt;INL_73>>> в заголовке сообщения в формате &lt;&lt;&lt;INL_74>>>. Например, если она хочет вызвать функцию &lt;&lt;&lt;INL_75>>> из примера выше, то укажет &lt;&lt;&lt;INL_76>>> в заголовке и &lt;&lt;&lt;INL_77>>> в качестве канала, как указано в [системном сообщении](#system-message-format). **Получатель может быть указан в роли или в секции канала заголовка.**

Модель также может указать токен &lt;&lt;&lt;INL_78>>> для обозначения типа входных данных для вызова инструмента. В случае передачи в формате JSON, &lt;&lt;&lt;INL_79>>> будет установлен в &lt;&lt;&lt;INL_80>>>.

&lt;&lt;&lt;CODE_16>>>

#### Обработка вызовов инструментов

После обработки вызова функции нам нужно вернуть результат модели, указав новое сообщение инструмента с выводом после сообщения вызова.

Сообщение инструмента имеет следующий формат:

&lt;&lt;&lt;CODE_17>>>

В нашем примере:

&lt;&lt;&lt;CODE_18>>>

Получив результаты вызовов инструментов, вы можете запустить новую выборку с полной информацией:

&lt;&lt;&lt;CODE_19>>>

Как видно, мы передаём обратно в модель не только вывод функции, но и предыдущую цепочку рассуждений («Нужно использовать функцию get_current_weather.»), чтобы предоставить модели необходимую информацию для продолжения рассуждений или выдачи окончательного ответа.

#### Преамбулы

Иногда модель может сгенерировать «преамбулу», чтобы проинформировать пользователя о инструментах, которые она собирается вызвать, например, если планируется вызов нескольких функций. В таком случае будет создано сообщение ассистента в канале &lt;&lt;&lt;INL_81>>>, которое, в отличие от цепочки рассуждений, предназначено для конечного пользователя.

&lt;&lt;&lt;CODE_20>>>

В этом случае модель сформировала план действий для информирования пользователя о нескольких шагах, которые собирается выполнить.

### Структурированный вывод

Чтобы управлять поведением вывода модели, можно определить формат ответа в конце [сообщения разработчика](#developer-message-format) со следующей структурой:

&lt;&lt;&lt;CODE_21>>>

Имя формата работает аналогично имени, которое можно указать для вашей схемы в [Responses API](https://platform.openai.com/docs/guides/structured-outputs?api-mode=responses#how-to-use), а сама схема соответствует JSON Schema.

Например, вот сообщение разработчика с определением схемы для списка покупок:

&lt;&lt;&lt;CODE_22>>>

Однако только эта подсказка повлияет на поведение модели, но не гарантирует полного соответствия схеме. Для этого требуется собственная грамматика и применение схемы при выборке.

### Встроенные инструменты

Во время обучения &lt;&lt;&lt;INL_82>>> моделей они были обучены с двумя распространёнными инструментами для поиска информации в браузере и выполнения кода Python для улучшения результатов.

Если вы хотите реализовать такую функциональность, используйте формат ниже для большей надёжности и точности.

Эти инструменты следует определять в [системном сообщении](#system-message-format), а не в сообщении разработчика, добавляя секцию &lt;&lt;&lt;INL_83>>>.

#### Инструмент браузера

Чтобы определить инструмент браузера, добавьте его в системный раздел подсказки:

&lt;&lt;&lt;CODE_23>>>

Если модель решит вызвать действия в браузере, она будет использовать тот же формат, что и для [вызовов функций](#function-calling), с двумя важными отличиями:

1. Запросы направляются в канал &lt;&lt;&lt;INL_84>>>
2. Получателем будет &lt;&lt;&lt;INL_85>>>, &lt;&lt;&lt;INL_86>>>, &lt;&lt;&lt;INL_87>>> соответственно

#### Инструмент Python

&lt;&lt;&lt;CODE_24>>>

Если модель решит выполнить Python-код, она будет использовать тот же формат, что и для [вызовов функций](#function-calling), с двумя важными отличиями:

3. Запросы идут в канал &lt;&lt;&lt;INL_88>>>
4. Получателем всегда будет &lt;&lt;&lt;INL_89>>>