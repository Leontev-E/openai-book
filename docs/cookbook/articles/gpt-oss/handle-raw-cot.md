---
lang: ru
translationOf: openai-cookbook
---

# Как работать с необработанной цепочкой рассуждений (CoT) в gpt-oss

Модели [gpt-oss](https://openai.com/open-models) предоставляют доступ к необработанной цепочке рассуждений (Chain of Thought, CoT), предназначенной для анализа и исследований безопасности разработчиками моделей. Это также важно для корректной работы вызова инструментов, так как вызовы инструментов могут выполняться как часть CoT. В то же время необработанная CoT может содержать потенциально вредоносный контент или раскрывать пользователям информацию, которую разработчик модели не хотел бы показывать (например, правила, указанные в инструкциях для модели). Поэтому необработанную CoT не следует показывать конечным пользователям.

## Обработка в Harmony / шаблонах чата

Модель кодирует свою необработанную CoT как часть нашего [формата ответа Harmony](https://cookbook.openai.com/articles/openai-harmony). Если вы создаёте собственные шаблоны для чата или работаете с токенами напрямую, обязательно [ознакомьтесь сначала с гайдом по Harmony](https://cookbook.openai.com/articles/openai-harmony).

Кратко об основных моментах:

1. CoT будет выводиться в канал &lt;&lt;&lt;INL_0>>>
2. После сообщения в канал &lt;&lt;&lt;INL_1>>> в следующем ходе выборки все сообщения &lt;&lt;&lt;INL_2>>> должны быть отброшены. Вызовы функций в канал &lt;&lt;&lt;INL_3>>> могут оставаться
3. Если последнее сообщение ассистента было вызовом инструмента любого типа, сообщения анализа до предыдущего сообщения &lt;&lt;&lt;INL_4>>> должны сохраняться при последующих вызовах выборки до тех пор, пока не будет выведено сообщение &lt;&lt;&lt;INL_5>>>

## Chat Completions API

Если вы реализуете API для дополнений в чат, официальной спецификации для работы с цепочкой рассуждений в опубликованных спецификациях OpenAI нет, поскольку наши размещённые модели пока не предлагают эту функцию. Мы рекомендуем следовать [следующему соглашению от OpenRouter](https://openrouter.ai/docs/use-cases/reasoning-tokens), включая:

1. Необработанная CoT возвращается как часть ответа, если в запросе не указан &lt;&lt;&lt;INL_6>>>. [Подробнее здесь](https://openrouter.ai/docs/use-cases/reasoning-tokens#legacy-parameters)
2. Необработанная CoT доступна как свойство &lt;&lt;&lt;INL_7>>> в сообщении в ответе
3. Для событий-дельт у дельты есть свойство &lt;&lt;&lt;INL_8>>>
4. В последующих ходах вы должны иметь возможность получать предыдущие рассуждения (в виде &lt;&lt;&lt;INL_9>>>) и обрабатывать их согласно поведению, описанному в разделе о шаблонах чата выше.

В случае сомнений следуйте соглашениям и поведению реализации OpenRouter.

## Responses API

Для Responses API мы расширили спецификацию, чтобы охватить этот случай. Ниже представлены изменения в спецификации в виде определений типов. В общих чертах мы:

1. Вводим новое свойство &lt;&lt;&lt;INL_10>>> у &lt;&lt;&lt;INL_11>>>, которое позволяет вместе с необработанной CoT (не показывать конечному пользователю, но полезно для исследовательских целей) возвращать рассуждения &lt;&lt;&lt;INL_12>>>, которые могут быть показаны конечному пользователю.
2. Вводим новый тип содержимого под названием &lt;&lt;&lt;INL_13>>>
3. Вводим два новых события: &lt;&lt;&lt;INL_14>>> для потоковой передачи дельт необработанной CoT и &lt;&lt;&lt;INL_15>>> для обозначения завершения хода CoT
4. В последующих ходах вы должны иметь возможность получать предыдущие рассуждения и обрабатывать их согласно поведению, описанному в разделе шаблонов чата выше.

**Изменения в типах элементов**

&lt;&lt;&lt;CODE_0>>>

**Изменения в событиях**

&lt;&lt;&lt;CODE_1>>>

**Пример вывода ответа**

&lt;&lt;&lt;CODE_2>>>

## Отображение необработанной CoT конечным пользователям

Если вы предоставляете пользователям чат-интерфейс, не показывайте необработанную CoT, так как она может содержать потенциально вредоносный контент или другую информацию, которую вы не хотите демонстрировать пользователям (например, инструкции в сообщении разработчика). Вместо этого рекомендуется показывать обобщённую CoT, аналогично нашим производственным решениям в API или ChatGPT, где модель-резюматор проверяет и блокирует вредоносный контент для отображения.