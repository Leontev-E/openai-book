---
lang: ru
translationOf: openai-cookbook
---

# Как обрабатывать необработанную цепочку рассуждений в gpt-oss

Модели [gpt-oss](https://openai.com/open-models) предоставляют доступ к необработанной цепочке рассуждений (CoT), предназначенной для анализа и исследований безопасности разработчиками моделей, но она также критична для работы вызова инструментов, поскольку вызовы инструментов могут выполняться как часть CoT. В то же время, необработанная CoT может содержать потенциально вредоносный контент или раскрывать пользователям информацию, которую создатель модели не намеревался показывать (например, правила, указанные в инструкциях, данных модели). Поэтому необработанную CoT не следует показывать конечным пользователям.

## Обработка Harmony / шаблона чата

Модель кодирует свою необработанную CoT как часть нашего [формата ответа harmony](https://cookbook.openai.com/articles/openai-harmony). Если вы создаете собственные шаблоны чата или работаете напрямую с токенами, обязательно [ознакомьтесь сначала с руководством по harmony](https://cookbook.openai.com/articles/openai-harmony).

Вкратце:

1. CoT будет выводиться на канал &lt;&lt;&lt;INL_0>>>
2. После сообщения на канал &lt;&lt;&lt;INL_1>>> в следующем раунде сэмплирования все сообщения &lt;&lt;&lt;INL_2>>> должны быть отброшены. Вызовы функций на канал &lt;&lt;&lt;INL_3>>> могут оставаться
3. Если последнее сообщение ассистента было вызовом инструмента любого типа, сообщения анализа до предыдущего сообщения &lt;&lt;&lt;INL_4>>> должны сохраняться в последующих сэмплированиях до тех пор, пока не будет выдано сообщение &lt;&lt;&lt;INL_5>>>

## Chat Completions API

Если вы реализуете Chat Completions API, в опубликованных спецификациях OpenAI нет официального задания для обработки цепочки рассуждений, так как наши размещённые модели пока не предлагают эту функцию. Мы просим вас следовать [следующему соглашению от OpenRouter](https://openrouter.ai/docs/use-cases/reasoning-tokens). В частности:

1. Необработанная CoT будет возвращена как часть ответа, если только в запросе не указан &lt;&lt;&lt;INL_6>>>. [Подробнее здесь](https://openrouter.ai/docs/use-cases/reasoning-tokens#legacy-parameters)
2. Необработанная CoT доступна в свойстве &lt;&lt;&lt;INL_7>>> сообщения в ответе
3. Для событий дельты у дельты есть свойство &lt;&lt;&lt;INL_8>>>
4. В последующих раундах вы сможете получить предыдущие рассуждения (как &lt;&lt;&lt;INL_9>>>) и обрабатывать их согласно поведению, описанному в разделе шаблонов чата выше.

Если сомневаетесь, следуйте соглашению / поведению реализации OpenRouter.

## Responses API

Для Responses API мы расширили спецификацию, чтобы охватить этот случай. Ниже изменения спецификации в виде определений типов. В общем виде мы:

1. Вводим новое свойство &lt;&lt;&lt;INL_10>>> у &lt;&lt;&lt;INL_11>>>, что позволяет возвращать рассуждения &lt;&lt;&lt;INL_12>>>, которые могут быть отображены конечному пользователю, одновременно с необработанной CoT (которую нельзя показывать конечному пользователю, но которая может быть полезна для исследований интерпретируемости).
2. Вводим новый тип содержимого с названием &lt;&lt;&lt;INL_13>>>
3. Вводим два новых события &lt;&lt;&lt;INL_14>>>, чтобы передавать дельты необработанной CoT, и &lt;&lt;&lt;INL_15>>>, чтобы указывать завершение текущего раунда CoT
4. В последующих раундах вы сможете получить предыдущие рассуждения и обрабатывать их согласно поведению из раздела шаблонов чата.

**Изменения типа элемента**

&lt;&lt;&lt;CODE_0>>>

**Изменения событий**

&lt;&lt;&lt;CODE_1>>>

**Пример вывода ответов**

&lt;&lt;&lt;CODE_2>>>

## Отображение необработанной CoT конечным пользователям

Если вы предоставляете чат-интерфейс пользователям, не показывайте необработанную CoT, так как она может содержать потенциально вредоносный контент или другую информацию, которую вы не хотели бы показывать пользователям (например, инструкции в сообщении для разработчика). Вместо этого рекомендуем отображать суммированную CoT, аналогично нашим промышленным реализациям в API или ChatGPT, где модель-сумматор проверяет и блокирует вредоносный контент для отображения.