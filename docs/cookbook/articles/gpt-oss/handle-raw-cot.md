---
lang: ru
translationOf: openai-cookbook
---

# Как обрабатывать сырой цепочку рассуждений (chain of thought) в gpt-oss

Модели [gpt-oss](https://openai.com/open-models) предоставляют доступ к сырой цепочке рассуждений (CoT) для анализа и исследований безопасности разработчиками моделей, но она также имеет ключевое значение для производительности вызова инструментов, поскольку вызовы инструментов могут выполняться как часть CoT. В то же время сырая CoT может содержать потенциально вредоносный контент или раскрывать пользователям информацию, которую разработчик модели не хочет показывать (например, правила, указанные в инструкциях для модели). Поэтому не следует показывать сырой CoT конечным пользователям.

## Обработка в Harmony / шаблоны чата

Модель кодирует свою сырую цепочку рассуждений как часть нашего [формата ответа harmony](https://cookbook.openai.com/articles/openai-harmony). Если вы создаёте собственные шаблоны для чата или работаете с токенами напрямую, обязательно [ознакомьтесь сначала с руководством по harmony](https://cookbook.openai.com/articles/openai-harmony).

Кратко по основным моментам:

1. CoT направляется в канал `analysis`
2. После сообщения в канал `final` в следующем раунде выборки все сообщения из канала `analysis` должны быть отброшены. Вызовы функций в канал `commentary` могут оставаться
3. Если последнее сообщение ассистента было вызовом инструмента любого типа, сообщения анализа до предыдущего сообщения с тегом `final` должны быть сохранены при последующих выборках до появления нового сообщения `final`

## Chat Completions API

Если вы реализуете Chat Completions API, в опубликованных спецификациях OpenAI нет официального стандарта для обработки цепочки рассуждений, так как наши хостинговые модели пока не предоставляют эту функцию. Мы рекомендуем следовать [следующему соглашению от OpenRouter](https://openrouter.ai/docs/use-cases/reasoning-tokens). Включая:

1. Сырая CoT возвращается как часть ответа, если в запросе не указано `reasoning: { exclude: true }`. [Подробности здесь](https://openrouter.ai/docs/use-cases/reasoning-tokens#legacy-parameters)
2. Сырая CoT отображается как свойство `reasoning` в сообщении ответа
3. Для дельта-событий дельта содержит свойство `reasoning`
4. В последующих раундах вы должны получать предыдущую цепочку рассуждений (как `reasoning`) и обрабатывать её в соответствии с поведением, описанным в разделе про шаблоны чата выше.

При сомнениях следуйте соглашению и поведению реализации OpenRouter.

## Responses API

Для Responses API мы расширили нашу спецификацию, чтобы покрыть этот случай. Ниже представлены изменения в спецификации в виде определений типов. Основные моменты:

1. Добавлено новое свойство `content` в объекте `reasoning`. Это позволяет возвращать сводку рассуждений, которая может отображаться конечному пользователю, одновременно с сырой CoT (которую не следует показывать пользователю, но она может быть полезна для исследований интерпретируемости).
2. Введён новый тип содержимого `reasoning_text`
3. Добавлены два новых события: `response.reasoning_text.delta` — для передачи дельт сырой CoT, и `response.reasoning_text.done` — для обозначения завершения раунда CoT
4. В последующих раундах вы должны иметь возможность получать предыдущие рассуждения и обрабатывать их в соответствии с поведением, описанным в разделе шаблонов чата выше.

**Изменения типов элементов**

&lt;&lt;&lt;CODE_0&gt;>>

**Изменения событий**

&lt;&lt;&lt;CODE_1&gt;>>

**Пример вывода ответов**

&lt;&lt;&lt;CODE_2&gt;>>

## Отображение сырой CoT конечным пользователям

Если вы предоставляете пользователям интерфейс чата, не показывайте им сырой CoT, так как он может содержать потенциально вредоносный контент или другую информацию, которую вы не хотите демонстрировать пользователям (например, инструкции в сообщении разработчика). Вместо этого рекомендуется показывать свёрнутую (резюмированную) CoT, аналогично нашим производственным реализациям в API или ChatGPT, где модель-сумматор просматривает и блокирует вредоносный контент в выводе.