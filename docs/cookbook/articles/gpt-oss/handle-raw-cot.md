---
lang: ru
translationOf: openai-cookbook
---

# Как обрабатывать необработанную цепочку рассуждений (raw chain of thought) в gpt-oss

Модели [gpt-oss](https://openai.com/open-models) предоставляют доступ к необработанной цепочке рассуждений (CoT), предназначенной для анализа и исследований безопасности разработчиками моделей, но она также имеет решающее значение для работы вызова инструментов, так как вызовы инструментов могут выполняться как часть CoT. В то же время, необработанная CoT может содержать потенциально вредоносный контент или раскрывать пользователям информацию, которую человек, реализующий модель, может не хотеть показывать (например, правила, указанные в инструкциях, переданных модели). Поэтому вы не должны показывать необработанную CoT конечным пользователям.

## Обработка в Harmony / шаблоне чата

Модель кодирует свою необработанную CoT как часть нашего [формата ответа harmony](https://cookbook.openai.com/articles/openai-harmony). Если вы создаёте собственные шаблоны чата или обрабатываете токены напрямую, обязательно [ознакомьтесь сначала с руководством по harmony](https://cookbook.openai.com/articles/openai-harmony).

Кратко подытожим несколько моментов:

1. CoT будет отправлена в канал `analysis`
2. После сообщения в канал `final` в следующем цикле семплирования все сообщения из `analysis` должны быть отброшены. Вызовы функций в канал `commentary` могут остаться
3. Если последнее сообщение помощника было вызовом инструмента любого типа, сообщения анализа до предыдущего сообщения `final` должны сохраняться в последующих семплированиях до появления нового сообщения `final`

## Chat Completions API

Если вы реализуете Chat Completions API, необходимо отметить, что в опубликованных OpenAI спецификациях нет официального стандарта обработки цепочки рассуждений, поскольку наши размещённые модели пока не предлагают эту функцию. Мы рекомендуем следовать [следующему соглашению от OpenRouter](https://openrouter.ai/docs/use-cases/reasoning-tokens), которое включает:

1. Необработанная CoT возвращается как часть ответа, если не указано `reasoning: { exclude: true }` в запросе. [Подробнее здесь](https://openrouter.ai/docs/use-cases/reasoning-tokens#legacy-parameters)
2. Необработанная CoT доступна в свойстве `reasoning` в сообщении ответа
3. Для дельта-событий дельта содержит свойство `reasoning`
4. В последующих циклах вы должны иметь возможность получать предыдущее reasoning (в виде `reasoning`) и обрабатывать его в соответствии с поведением, описанным в разделе про шаблоны чата.

При сомнениях, пожалуйста, следуйте соглашениям и поведению реализации OpenRouter.

## Responses API

Для Responses API мы расширили спецификацию, чтобы охватить этот случай. Ниже представлены изменения в спецификации в виде определений типов. В общих чертах мы делаем следующее:

1. Вводим новое свойство `content` в `reasoning`. Это позволяет возвращать summary рассуждений, которые могут показываться конечному пользователю, одновременно с необработанной CoT (которую показывать нельзя, но она может быть полезна для исследований интерпретируемости).
2. Вводим новый тип контента с названием `reasoning_text`
3. Вводим два новых события — `response.reasoning_text.delta` для потоковой передачи дельт необработанной CoT и `response.reasoning_text.done`, обозначающее завершение одного цикла CoT
4. В последующих циклах вы должны получать предыдущие рассуждения и обрабатывать их согласно поведению, описанному в разделе про шаблоны чата.

**Изменения в типах элементов**

&lt;&lt;&lt;CODE_0&gt;>>

**Изменения в событиях**

&lt;&lt;&lt;CODE_1&gt;>>

**Пример вывода ответов**

&lt;&lt;&lt;CODE_2&gt;>>

## Отображение необработанной CoT конечным пользователям

Если вы предоставляете пользователям интерфейс чата, не показывайте необработанную CoT, поскольку она может содержать потенциально вредоносный контент или другую информацию, которую вы можете не хотеть показывать пользователям (например, инструкции в сообщении разработчика). Вместо этого мы рекомендуем показывать резюмированную CoT, аналогично нашим производственным реализациям в API или ChatGPT, где модель-сумматор просматривает и блокирует показ вредоносного содержимого.